<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Mathematical Foundations of Quantum Computing</title>

		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/white.css">

        <link rel="stylesheet" href="css/extra/reveal_extra.css">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="plugin/highlight/monokai.css">
	</head>
	<body>
		<div class="reveal">
			<div class="slides">

<section data-markdown>
## Quantum Algorithms
### and
## Applications to Machine Learning

Pranay Raja Krishnan

22MMT002

The LNM Institute of Information & Technology

Jaipur

</section>

<section data-markdown>
### Contents
* Foundations of Quantum Computing
* Quantum Algorithms
    * Deutsch Algorithm
    * Simon's Algorithm
    * Grover's Algorithm
    * Quantum Fourier Transform
    * Quantum Phase Estimation
    * HHL Algorithm
* Applications to Machine Learning
</section>

<section data-markdown>
# Foundations of Quantum Computing
</section>
<section data-markdown>
### Foundations of Quantum Computing

* The **qubit** forms the foundational unit of computing
* A qubit can be represented as a mathematical model with the following principles:
    * Principle of Superposition
    * Principle of Transformation
    * Principle of Measurement
    * Principle of Entanglement
</section>

<section data-markdown>
### Foundations of Quantum Computing
##### Principle of Superposition
> The state of every qubit can be represented by a unit vector in a 2-dimensional complex Hilbert space

The state is normally described with respect to the **computational basis** $\\{ \\; \ket{0}, \ket{1} \\; \\} $
where 

$\ket{0} = 1 + 0 i = \begin{bmatrix} 1 \\\\ 0 \end{bmatrix}$ and $\ket{1} = 0 + 1 i = \begin{bmatrix} 0 \\\\ 1 \end{bmatrix}$
</section>

<section data-markdown>
### Foundations of Quantum Computing
##### Principle of Transformation
> Any change in the state of a qubit can be described by the action of a unitary transformation

A unitary transformation is a linear isomorphism that preserves the inner product.

This can be represented by a unitary matrix $U$ where $$U U^\dagger = U^\dagger U = I$$

</section>

<section data-markdown>
### Foundations of Quantum Computing
##### Principle of Measurement
Consider the qubit in state $\ket{\psi} = a \ket{0} + b \ket{1}$ and a measurement device calibrated to the computational basis

> The action of measurement causes the state of the qubit to collapse into either $\ket{0}$ or $\ket{1}$ which will be output of measurement

The probability of measuring $\ket{0}$ is $|a|^2$ and the probability of measuring $\ket{1}$ is $|b|^2$

</section>

<section data-markdown>
### Foundations of Quantum Computing
##### Principle of Entanglement

> Multiple qubits interacting together results in the state space of the combined system being the *tensor product space* of the individual qubit state spaces

The tensor product $\ket{\psi} \otimes \ket{\phi} = \begin{bmatrix} a \\\\ b \end{bmatrix} \begin{bmatrix} c \\\\ d \end{bmatrix} = \begin{bmatrix} ac \\\\ ad \\\\ bc \\\\ bd \end{bmatrix}$

</section>
<section data-markdown>
### Foundations of Quantum Computing
##### Principle of Entanglement

> Two interacting qubits have a state space of dimension 4

The state space for two interacting qubits has the **computational basis** $\\{\\; \ket{0}, \ket{1}, \ket{2}, \ket{3} \\; \\}$ where 

 $\ket{0} = \ket{0} \otimes \ket{0} \qquad \ket{1} = \ket{0} \otimes \ket{1}$

 $\ket{2} = \ket{1} \otimes \ket{0} \qquad \ket{3} = \ket{1} \otimes \ket{1}$



</section>
<section data-markdown>
### Foundations of Quantum Computing
##### Principle of Entanglement

> $n$ interacting qubits have a state space of dimension $2^n$

The state space for two interacting qubits has the **computational basis** $\\{\\; \ket{0}, \ket{1}, \ket{2}, ..., \ket{2^n - 1} \\; \\}$ where 

 $\ket{0} = \underbrace{\ket{0} \otimes \ket{0} \otimes ... \otimes \ket{0}}_{n \text{ times}}$

 $\ket{2^n - 1} = \underbrace{\ket{1} \otimes \ket{1} \otimes ... \otimes \ket{1}}_{n \text{ times}}$

</section>

<section data-markdown>
### Foundations of Quantum Computing
##### Principle of Entanglement

> Most states in the tensor product space cannot be expressed as the tensor product of states in the individual qubits

For example:

The state $\ket{\phi^+} = \frac{1}{\sqrt{2}} ( \ket{0} + \ket{1} )$ cannot be expressed as a tensor product of two individual qubit states


</section>

<section data-markdown>
# Quantum Algorithms
</section>
<section data-markdown>
### Deutsch-Jozsa Algorithm

A function $f: \mathbb{Z}_n \to \\{ 0, 1 \\}$ is said to be **constant** when $f(x) = f(y)$ for all $x$ and $y$ in $\mathbb{Z}_n$. 

A function $f: \mathbb{Z}_n \to \\{ 0, 1 \\}$ is said to be **balanced** if an equal number of input values to the function return $0$ and $1$.
    
> Given a funtion $f: \mathbb{Z}_n \to \\{0,1\\}$, determine whether the function is constant or balanced.

* Classical algorithms can solve this problem in $O(n)$
* Deutsch-Jozsa algorithm can solve this problem in $O(1)$

Note:
proposed by David Deutsch and Richard Jozsa in 1992

Although of little practical use, it is one of the first examples of a quantum algorithm that is exponentially faster than any possible deterministic classical algorithm.
</section>

<section data-markdown>
### Simon's Algorithm


Let  $\oplus$ represent addition modulo 2

> Given a 2 to 1 function $f$ satisfying the property that there exists a fixed $a \in \\{ 0, 1 \\}^n$ such that $f(x) = f(x \oplus a)$ for all $x \in \\{ 0,1 \\}^n$.  
> Find the fixed string $a$. 

* Classical randomized algorithms are known to have a worst-case time complexity of $O(2^{n/2})$
* Simon's algorithm solves the problem statement with a time complexity of $O(n)$

Note:
served as the inspiration for Shor's algorithm
1994
</section>

<section data-markdown>
### Grover's Algorithm

> Consider a set $X$ with $N$ elements and let $f: X \to \\{ 0,1 \\}$ be a boolean function such that $f(x) = 1$ for exactly one element $x_0 \in X$.  
> Find the element $x_0$.

* Classical algorithms have a time complexity of $O(N)$
* Grover's algorithm solves this problem with a time complexity of $O(\sqrt{N})$

</section>
<section data-markdown>
### Grover's Algorithm

> Consider a set $X$ with $N$ elements and let $f: X \to \\{ 0,1 \\}$ be a boolean function such that $f(x) = 1$ for exactly one element $x_0 \in X$.  
> Find the element $x_0$.

* First presented by Lov Kumar Grover as a database search algorithm
* The problem statement represents an unstructured search problem 
* Grover's algorithm is proven to be optimal

Note:
1996
</section>


<section data-markdown>
### Quantum Fourier Transform
Let $\omega = \exp\left(  \frac{ 2\pi i}{N} \right)$

>  The **Discrete Fourier Transform (DFT)** is a function $F\_N: \mathbb{C}^N \to \mathbb{C}^N$ that transforms a vector of complex numbers $\\begin{bmatrix} x\_0  & x\_1 & ... & x\_{N-1} \\end{bmatrix}^T$ into another vector of complex numbers $\begin{bmatrix} y\_0  & y\_1 & ... & y\_{N-1} \end{bmatrix}^T$ such that $$y\_k = \frac{1}{\sqrt{N}} \sum_{j=0}^{N-1} x\_j \exp\left(-\frac{2 \pi i }{N} k j \right) = \frac{1}{\sqrt{N}} \sum_{j=0}^{N-1} x\_j \omega^{-kj}$$ 

</section>
<section data-markdown>
### Quantum Fourier Transform
 > The **Inverse Discrete Fourier Transform (IDFT)** is a function  
 > $F_N^{-1}: \mathbb{C}^N \to \mathbb{C}^N$ transforms a vector of complex numbers $\\begin{bmatrix} x\_0  & x\_1 & ... & x\_{N-1} \\end{bmatrix}^T$ into another vector of complex numbers $\begin{bmatrix} y\_0  & y\_1 & ... & y\_{N-1} \end{bmatrix}^T$ such that
$$y_k = \frac{1}{\sqrt{N}} \sum_{j=0}^{N-1} x_j \omega^{kj}$$
</section>
<section data-markdown>
### Quantum Fourier Transform

> The **Quantum Fourier Transform (QFT)** is the quantum gate with matrix representation $F_N^{-1}$ for some $N = 2^n$ and it transforms an $n$-qubit state $\ket{\psi} = \sum_{j=0}^{N-1} x_j \ket{j}$ to another $n$-qubit state $\ket\phi =\sum_{k=0}^{N-1} y_k \ket{k}  $ such that 
    $$y_k = \frac{1}{\sqrt{N}}\sum_{j=0}^{N-1} x_j \omega^{k j}$$

    
</section>
<section data-markdown>
### Quantum Fourier Transform
* Evaluating the matrix operations of $F_N$ to evaluate the DFT requires $N^2$ operations, so DFT has a time complexity of $O(N^2)$
* Using a faster algorithm known as *Fast Fourier Transform (FFT)* allows us to calculate the DFT in $O(N \log N)$
* The QFT performs an action similar to the DFT in only $O((\log N)^2 )$
Note:
However, since the action is performed on the amplitudes of the quantum states, we cannot use the QFT as a replacement for the DFT
It still finds much use as a subroutine in other quantum algorithms
</section>

<section data-markdown>
### Quantum Phase Estimation
> Given a unitary transformation $U$ and an eigenvector $\ket\phi$ of $U$.  
> Find the eigenvalue associated with this eigenvector $\ket\phi$. 

$U$ is unitary implies that its eigenvalues are complex numbers of unit amplitude.

The eigenvalue associated to the eigenvector $\ket\phi$ can be written as $e^{2 \pi i \theta}$ which allows us to characterise the eigenvalue by its phase $\theta \in [0, 1)$

Note:
1995
</section>

<section data-markdown>
### HHL Algorithm

>  Consider a system of linear equations represented as $A \vec{x} = \vec{b}$ where $A$ is an $N\times N$ *self-adjoint* matrix and $\vec{x}$ and $\vec{b}$ are $N$-dimensional vectors.  
> Find the solution $\vec{x} = A^{\-1} \vec{b}$

* Can also be applied to non-self-adjoint matrices $A$ by using the block matrix $\begin{bmatrix}
        0 & A \\\\ A^\dagger & 0
    \end{bmatrix}$ which is self-adjoint
* The *Conjugate Gradient Method* has a time complexity of $O(N)$
* HHL Algorithm finds the solution in $O(\log N)$

Note:
2008
</section>

<section data-markdown>
# Applications to Machine Learning
</section>
<section data-markdown>
### Quantum Optimization
</section>

<section data-markdown>
### References
* Rieffel, Eleanor and Polak; Wolfgang Quantum computing: A gentle Introduction, Scientific and Engineering Computation, MIT Press, Cambridge, MA (2011)
* Lov K. Grover; A fast quantum mechanical algorithm for database search [Paper](https://arxiv.org/abs/quant-ph/9605043), (1996)
* Brassard & Hoyer; Quantum Amplitude Amplification and Estimation, [Paper](https://arxiv.org/abs/quant-ph/0005055), (2000)
</section>


			</div>
		</div>

		<script src="dist/reveal.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
        <script src="plugin/math/math.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
                width: 1110,
                height: 700,
				hash: true,
                slideNumber: true,
				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMarkdown, RevealHighlight, RevealNotes, RevealMath.KaTeX ]
			});
		</script>
	</body>
</html>

