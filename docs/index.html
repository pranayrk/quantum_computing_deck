<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Grover's Algorithm</title>

		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/black.css">

        <link rel="stylesheet" href="css/extra/reveal_extra.css">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="plugin/highlight/monokai.css">
	</head>
	<body>
		<div class="reveal">
			<div class="slides">

<section data-markdown>
## Grover's Algorithm

Pranay Raja Krishnan

22MMT002

The LNM Institute of Information & Technology

Jaipur

</section>

<section data-markdown>
### Key Points
* Devised by Lov Kumar Grover in 1996
* One of the most famous quantum algorithm second to only Shor's algorithm
* Does not have as impressive of a speedup as Shor's but is applicable to a broader range of problems
* Targets an unstructured search problem and finds the solution with high probability
* Original paper introduces it as a database search algorithm but it finds limited use in this case

Note:
* Shor's has an exponential speedup while Grover's has only quadratic speedup
* Grover's algorithm could brute-force a 128-bit symmetric cryptographic key in roughly $2^64$ iterations, or a 256-bit key in roughly $2^128$ iterations. 
</section>

<section data-markdown>
### Computational Basis of Multiple Qubits
* For $1$ qubit, the computational basis is $\\{ \ket{0}, \ket{1} \\}$
* For $2$ qubits, the computational basis is $\\{ \ket{0}, \ket{1}, \ket{2}, \ket{3} \\}$ where 
   * $\ket{0} = \ket{00} = \ket{0} \otimes \ket{0}$
   * $\ket{1} = \ket{01} = \ket{0} \otimes \ket{1}$
   * $\ket{2} = \ket{10} = \ket{1} \otimes \ket{0}$
   * $\ket{3} = \ket{11} = \ket{1} \otimes \ket{1}$
* For $n$ qubits, the computational basis is $\\{ \ket{0}, \ket{1}, ..., \ket{2^n - 1} \\}$ where
    * $\ket{0} = \ket{00...00} = \underbrace{\ket{0} \otimes \ket{0} \otimes ... \otimes \ket{0}}_{n\text{ times }}$
    * $\ket{1} = \ket{00...01} = \underbrace{\ket{0} \otimes \ket{0} \otimes ... \otimes \ket{0}}_{n-1\text{ times }} \otimes \ket{1}$
    * $\ket{2^n - 1} = \ket{11...11} = \underbrace{\ket{1} \otimes \ket{1} \otimes ... \otimes \ket{1}}_{n\text{ times }}$
</section>


<section data-markdown>
### Hadamard Gate
> The **Hadamard gate** $H$ acts on a single qubit and is represented by the Hadamard matrix  
> $H = \displaystyle\frac{1}{\sqrt{2}} \begin{bmatrix} 1 & 1 \\\\ 1 & -1 \end{bmatrix}$

* The Hadamard gate acts on $\ket{0}, \ket{1}$ as:
    * $H\ket{0} = \frac{1}{\sqrt{2}} (\ket{0} + \ket{1}) = \ket{+}$ 
    * $H\ket{1} = \frac{1}{\sqrt{2}} (\ket{0} - \ket{1}) = \ket{-}$
* The Hadamard gate is self inverse, $H H = I$

Note:
* Creates an equal superposition of the basis states
* The conjugate transponse of $H$ is $H$ itself, so to check it is unitary, we only need to check $HH = I$
* $H\ket{+} = \ket{0}$ and $H\ket{-} = \ket{1}$
</section>
<section data-markdown>
### Hadamard Transform
> The **Hadamard transform** denoted $H^{\otimes n}$ represents the application of the Hadamard gate to each qubit of an $n$-qubit register in parallel.

Consider the Hadamard tranform applied to an $n$-qubit register, each qubit set to $\ket{0}$,

$H^{\otimes n} \ket{0}^n  = \underbrace{(H \ket{0}) \otimes (H \ket{0}) \otimes (H \ket{0}) \otimes ... \otimes (H \ket{0})}_{n\text{ times }}$

$= \underbrace{\frac{1}{2^{n/2}} (\ket{0} + \ket{1}) \otimes (\ket{0} + \ket{1}) \otimes (\ket{0} + \ket{1}) ... \otimes (\ket{0} + \ket{1})}_{n \text{ times }}$ 

$= \displaystyle\frac{1}{2^{n/2}} \sum_{j=0}^{2^n -1} \ket{j} \text{ where $\ket{j}$ is the bitstring that represents $j$ in binary}$
</section>

<section data-markdown>
### Reflection about a Vector
> Given vectors $\ket\psi, \ket\phi \in \mathcal{H}$, the operator $R_\psi = 2 \ket\psi \bra\psi - I$ applied to $\ket\phi$ represents the reflection of $\ket\phi$ about the direction of $\ket\psi$

Let $\mathcal{H}_\psi^\perp \subset \mathcal{H}$ represent the subspace of $\mathcal{H}$ orthogonal to $\ket\psi$.

Let $\ket{\psi^\perp} \in \mathcal{H}_\psi^\perp$ such that $\ket{\psi^\perp} = \ket\phi - a \ket\psi$ for some $a \in \mathbb{C}$ 

$\implies \ket\phi = a \ket\psi + \ket{\psi^\perp}$

$R_\psi \ket\phi = (2 \ket\psi \bra\psi - I) \ket\phi$

$ = 2 \ket\psi \bra\psi \ket\phi - \ket\phi = 2 \ket\psi \bra\psi ( a \ket\psi + \ket{\psi^\perp}) - \ket\phi$

$ = 2 a \ket\psi \braket{\psi|\psi} + 2 \ket\psi \braket{\psi|\psi^\perp} - \ket\phi = 2 a \ket\psi - \ket\phi$

$ = 2 a \ket\psi - (a \ket\psi + \ket{\psi^\perp}) = a \ket\psi - \ket{\psi^\perp}$

</section>
<section>
<h3>Reflection about a Vector</h3>
<blockquote><p>Given vectors $\ket\psi, \ket\phi \in \mathcal{H}$, the operator $R_\psi = 2 \ket\psi \bra\psi - I$ applied to $\ket\phi$ represents the reflection of $\ket\phi$ about the direction of $\ket\psi$</p></blockquote>

<img src="media/reflection.png" height="500"></img>
</section>
<section data-markdown>
### Reflection about a Vector
> Given vectors $\ket\psi, \ket\phi \in \mathcal{H}$, the operator $R_\psi = 2 \ket\psi \bra\psi - I$ is unitary and therefore is a valid quantum gate

$R_\psi R_\psi^\dagger = (2 \ket\psi\bra\psi - I)(2 \ket\psi\bra\psi - I)^\dagger$ 

$ = (2 \ket\psi\bra\psi - I) (2 (\ket\psi\bra\psi)^\dagger - I^\dagger)$

$ = (2 \ket\psi\bra\psi - I)(2 \ket\psi\bra\psi - I)$

*Because $(\ket\psi\bra\psi)^\dagger = \ket\psi\bra\psi$*

$ = 4\ket\psi\bra\psi - 2 \ket\psi \bra\psi - 2 \ket\psi \bra\psi + I = I$

</section>

<section data-markdown>
### Problem Setup

> We are given a set of $N$ distinct elements forming a set $X = \\{ x_1, x_2, ..., x_N \\}$  
> and a boolean function $f: X \to \\{ 0,1 \\}$ with $f(x) = 1$ for *exactly one* $x_i \in X$.  
> We are tasked with finding that unique $x_i$

* The problem above represents an unstructured search problem
* We need to search for the solution from a finite set of possible solutions
* Consider an example for such a problem:
    * A set of $N$ coins is laid out on a table heads up
    * One of these coins is flipped so that it is tails up
    * We need to find which coin has been flipped by checking only one coin at a time

Note:
* Unstructured means we cannot use any clever tricks like binary search
* Lov Grover designed this algorithm to be used for searching databases, where we need to match a certain query
* Like finding a needle in a haystack
</section>

<section data-markdown>
### Classical Approach
> We are given a set of $N$ distinct elements forming a set $X = \\{ x_1, x_2, ..., x_N \\}$
> and a boolean function $f: X \to \\{ 0,1 \\}$ with $f(x) = 1$ for *exactly one* $x_i \in X$.  
> We are tasked with finding that unique $x_i$

* The only classical deterministic algorithm is to query the function $f$ with each value of $x_i \in X$ until we find the solution $x_i$ with $f(x_i) = 1$
* On average we will require $\frac{N}{2}$ queries to $f$ to determine the solution, and in the worst case we will need $N$ queries to $f$
* This means that the algorithm will have a time complexity of $O(N)$
Note: 
* When we know the number of solutions, say $t$ solutions among $N$ possibilities, a randomized algorithm will give a time complexity of $O(\frac{N}{t})$
</section>

<section data-markdown>
### Grover's Algorithm
> We are given a set of $N$ distinct elements forming a set $X = \\{ x_1, x_2, ..., x_N \\}$
> and a boolean function $f: X \to \\{ 0,1 \\}$ with $f(x) = 1$ for *exactly one* $x_i \in X$.  
> We are tasked with finding that unique $x_i$

* Consider without loss of generality that $N = 2^n$ for some $n \in \mathbb{N}$
* Let each $x_i \in \\{ x_1, x_2, ..., x_N \\}$ correspond to the basis vector $\ket{i-1}$ in a quantum state space with basis vectors $\\{\ket{0}, \ket{1}, ..., \ket{N-1} \\}$
* Since $N = 2^n$, we will need to use an $n$-qubit register to achieve a suitable corresponding basis.
* Grover's algorithm relies on a black box circuit which tells us whether a particular $x_i$ is a solution
* We wrap this black box in a *quantum oracle* which takes a quantum state as input and can tell us whether a given basis vector $\ket{i}$ is a solution.

</section>

<section data-markdown>
### Oracle
> We are given a set of $N$ distinct elements forming a set $X = \\{ 0, 1, ..., 2^n-1 \\}$ and a boolean function $f: X \to \\{ 0,1 \\}$ with $f(x) = 1$ for *exactly one* $x_i \in X$

* Consider we have access to a classical circuit $\boxed{O_c}$ which takes input of $x \in X$ as a binary string, i.e. $x \in \\{0,1\\}^n$, and outputs $f(x)$</li>
* Since we have possible values of $x$ from $0$ to $2^n-1$, we will need an $n$-bit binary string as input to $\boxed{O_c}$</li>
* Using $\boxed{O_c}$ directly in Grover's algorithm by swapping in $\ket{x}$ will not work since is not a valid quantum gate</li>

</section>
<section data-markdown>
### Oracle
> We are given a set of $N$ distinct elements forming a set $X = \\{ 0, 1, ..., 2^n-1 \\}$ and a boolean function $f: X \to \\{ 0,1 \\}$ with $f(x) = 1$ for *exactly one* $x_i \in X$

* One way of rectifying this is by constructing a bit-oracle circuit $\boxed{U_f}$ in such a way that it has equal number of inputs and outputs. Also the circuit should be invertible.
* We define $\boxed{U_f}$ as the circuit such that $U_f(\ket{x}\ket{y}) = \ket{x}\ket{y \oplus f(x)}$ where $\oplus$ denotes addition modulo 2 and $\ket{y}$ is an extra ancilliary qubit given to hold the output.
* We are not concerned with the exact implementation of $\boxed{U_f}$ and think of it it as a black-box which we expect is provided to us
* To show $U_f$ is unitary and reversible, check [Sevag Gharibian's Lecture on Deutsch Algorithm, Section 1](https://people.vcu.edu/~sgharibian/courses/CMSC491/notes/Lecture%206%20-%20Deutsch%27s%20algorithm.pdf)
</section>
<section data-markdown>
### Oracle
> Given a bit-oracle circuit $\boxed{U_f}$ we can construct the phase-oracle $\boxed{U_\pm}$

* The circuit for $\boxed{U_f}$ has extra output qubit $\ket{y}$ to handle, this can be simplified to an $n$-qubit circuit.
* The approach for this is to construct a phase-oracle $\boxed{U_\pm}$ such that $U_\pm \ket{x} = \begin{cases} \ket{x} & \text{ if } f(x) = 0 \\\\ -\ket{x} & \text{ if } f(x) = 1 \end{cases} = (-1)^{f(x)} \ket{x}$
---
### Oracle
> Given a bit-oracle circuit $\boxed{U_f}$ we can construct the phase-oracle $\boxed{U_\pm}$

Suppose that we are given a bit-oracle circuit $\boxed{U_f}$ and the ancilliary $\ket{y}$ is set to $\ket{-}$.

Then the state of the input is $\ket{x}\otimes \ket{-} = \frac{1}{\sqrt{2}} (\ket{x0} - \ket{x1})$

*First case, $f(x) = 0$:* $U_f( \ket{x} \otimes \ket{-})$ leaves the state unchanged.

*Second case, $f(x) = 1$:* $U_f(\ket{x} \otimes \ket{-}) =  \ket{x} \otimes \frac{1}{\sqrt{2}} (\ket{0 \oplus 1} - \ket{1 \oplus 1})$

$ = \ket{x} \otimes \frac{1}{\sqrt{2}} (\ket{1} - \ket{0}) = \frac{1}{\sqrt{2}} (\ket{x1} - \ket{x0})$

$ \implies U_f(\ket{x} \otimes \ket{-}) = (-1)^{f(x)} (\ket{x} \otimes \ket{-})$ which is the action of the phase-oracle
</section>

<section data-markdown>
### Grover's Algorithm
> The circuit for Grovers algorithm $\boxed{G}$ performs the operation given by the operator  
> $G = \underbrace{D \cdot U_\pm \cdot....U_\pm \cdot D \cdot U_\pm \cdot D \cdot U_\pm}_{\text{ applied a certain number of times }} \cdot H^{\otimes n}$  

* The steps in the algorithm are:
    * Set the $n$-qubit register to $\ket{0}^n$
    * Apply the Hadamard Transform $H^{\otimes n}$
    * Repeat the following steps a certain number of times:
        * Apply the phase oracle $U_\pm$
        * Apply Grover's diffusion operator $D$
    * Measure the state of the $n$-qubit register

---
### Grover's Algorithm
> The circuit for Grovers algorithm $\boxed{G}$ performs the operation given by the operator  
> $G = \underbrace{D \cdot U_\pm \cdot....U_\pm \cdot D \cdot U_\pm \cdot D \cdot U_\pm}_{\text{ applied a certain number of times }} \cdot H^{\otimes n}$  

Let $k \in \\{ 0, 1 \\}^n$ be the required solution.

We will require the $n$-qubit register to be very close to the state $\ket{k} \in \ket{0}, ..., \ket{2^n-1}$.

Applying the Hadamard gate on $\ket{0}^n$, we get the register in the average state  
 $\ket\psi = H^{\otimes n} \ket{0}^n = \frac{1}{2^{n/2}} \sum_{i=0}^{2^n-1}\ket{j}$

Applying $U_\pm$ on this average state $\ket\psi$, we get  
 $U_\pm(\ket\psi) = U_\pm (\frac{1}{2^{n/2}} \sum_{j=0}^{2^n - 1} \ket{j}) $ 

$ = \frac{1}{2^{n/2}} \sum_{j=0}^{2^n-1} U_\pm (\ket{j}) = - \frac{1}{2^{n/2}} \ket{k} + \frac{1}{2^{n/2}} \sum_{j=0, j \neq k}^{2^n-1} \ket{j}$

---
### Grover's Algorithm
> The circuit for Grovers algorithm $\boxed{G}$ performs the operation given by the operator  
> $G = \underbrace{D \cdot U_\pm \cdot....U_\pm \cdot D \cdot U_\pm \cdot D \cdot U_\pm}_{\text{ applied a certain number of times }} \cdot H^{\otimes n}$  

* Grover's diffusion operator $D$ in the above algorithm is a gate which reflects any current state $\ket{\phi}$ of the $n$-qubit register about the axis of the average state   
   $\ket{\psi} = \frac{1}{2^{n/2}} \sum_{i=0}^{2^n-1}\ket{j}$
* We can represent the operation of $D$ as $D = 2 \ket\psi\bra\psi - I$

---
### Grover's Algorithm
> The circuit for Grovers algorithm $\boxed{G}$ performs the operation given by the operator  
> $G = \underbrace{D \cdot U_\pm \cdot....U_\pm \cdot D \cdot U_\pm \cdot D \cdot U_\pm}_{\text{ applied a certain number of times }} \cdot H^{\otimes n}$  

The mean amplitude of the state $U_\pm(\ket\psi)$ before applying $D$ is 

$\displaystyle \frac{\frac{-1}{2^{n/2}} + \frac{1}{2^{n/2}} (2^n -1) }{2^n} = \displaystyle \frac{(2^n - 2) \frac{1}{2^{n/2}}}{2^n} \approx \frac{2^n}{2^n} \frac{1}{2^{n/2}} = \frac{1}{2^{n/2}} = \frac{1}{\sqrt{N}}$

Therefore after reflection about $\ket\psi$, the amplitudes of most entries $\ket{j}$ where $j \neq k$ are slightly reduced but roughly the same.

However, for the solution $k \in \\{0,1 \\}^n$, the entry of $\ket{k}$ will be reflected to an amplitude of $\displaystyle\frac{3}{2^{n/2}} = \frac{3}{\sqrt{N}}$

---

### Grover's Algorithm
> The circuit for Grovers algorithm $\boxed{G}$ performs the operation given by the operator  
> $G = \underbrace{D \cdot U_\pm \cdot....U_\pm \cdot D \cdot U_\pm \cdot D \cdot U_\pm}_{\text{ applied a certain number of times }} \cdot H^{\otimes n}$  


After one application of $D U_\pm$, the amplitude of the solution component $\ket{k}$ will be $\displaystyle \frac{3}{\sqrt{N}}$   
and the amplitude of the non-solution components will be sligtly less than $\displaystyle\frac{1}{\sqrt{N}}$

If we apply $D U_\pm$ a second time, the amplitude of the solution component $\ket{k}$ will be $\displaystyle \frac{5}{\sqrt{N}}$ and the amplitude of the non-solutions will be even lower.

So $p$ applications of $D U_\pm$ will result in the solution component having an amplitude of $\displaystyle\frac{2p + 1}{\sqrt{N}}$ and the non-solution components will reduce in amplitude with each application.

---
### Grover's Algorithm
> The circuit for Grovers algorithm $\boxed{G}$ performs the operation given by the operator  
> $G = \underbrace{D \cdot U_\pm \cdot....U_\pm \cdot D \cdot U_\pm \cdot D \cdot U_\pm}_{\text{ applied a certain number of times }} \cdot H^{\otimes n}$  


Suppose we need to make the amplitude of the solution greater than a constant $A$.
So we proceed to apply $D U_\pm$ a total of $\displaystyle \frac{A\sqrt{N}}{2}$ times (rounded up) we will get the solution component having an amplitude of $\displaystyle \frac{2 \frac{A\sqrt{N}}{2} + 1}{\sqrt{N}} > A$ and the non-solution components will have very low amplitude for large $N$.

Since we repeat $D U_\pm$ a total of $\displaystyle \frac{A\sqrt{N}}{2}$ (rounded up), we see that Grover's algorithm has a time-complexity of $\frac{A}{2} \sqrt{N} \sim O(\sqrt{N})$



</section>

<section data-markdown>
### Amplitude Amplification Algorithm
> We are given a set of $N = 2^n$ distinct elements forming a set $X = \\{ x_1, x_2, ..., x_N \\}$
> and a boolean function $f: X \to \\{ 0,1 \\}$ with $f(x) = 1$ for *some* $x_i \in X$.   
> Given each $x_i$ corresponds to a basis element $\ket{i-1}$ of a quantum state space with basis $\\{\ket{0},\ket{1}, ...,\ket{N} \\}$, we want to bring the state space close to a uniform superposition of the basis vectors for which the corresponding $x_i$ satisfies $f(x_i) = 1$

* Generalization of Grover's original algorithm where there are multiple possible solutions in the solution space
* More precisely, Grover's original algorithm belongs to what we now call the class of amplitude amplification algorithms
* This finds use as a subroutine in many other quantum algorithms either to prepare the input as an equal superposition of certain basis states or to emphasize the effect of certain basis states
---
### Amplitude Amplification Algorithm
> Given a quantum state space of an $n$-qubit register with basis $\mathscr{B} = \\{\ket{0}, \ket{1}, ..., \ket{2^n-1} \\}$, and a subbasis $\mathscr{B}'$. 
> To bring the state of the register close to a superposition of basis vectors in $\mathscr{B}'$,
> we apply the algorithm $G = \underbrace{D \cdot U_\pm \cdot....U_\pm \cdot D \cdot U_\pm \cdot D \cdot U_\pm}_{\text{ applied a certain number of times }}$ to any initial state $\ket{\psi}$

* $U_\pm \ket{x} = \begin{cases} \ket{x} & \text{ if } f(x) \text{ is not a solution } \\\\ -\ket{x} & \text{ if } f(x) \text{ is a solution } \end{cases} = (-1)^{f(x)} \ket{x}$
* $U_\pm$ puts a negative sign for all $\ket{i}$ in the good state and none of $\ket{i}$ in the bad state
* $D = 2 \ket\psi \bra\psi - I$ and is normally written as $H^{\otimes n} (2 \ket{0}\bra{0} - I) H^{\otimes n}$ in most sources

---
### Amplitude Amplification Algorithm
> Given a quantum state space of an $n$-qubit register with basis $\mathscr{B} = \\{\ket{0}, \ket{1}, ..., \ket{2^n-1} \\}$, and a subbasis $\mathscr{B}'$. 
> To bring the state of the register close to a superposition of basis vectors in $\mathscr{B}'$,
> we apply the algorithm $G = \underbrace{D \cdot U_\pm \cdot....U_\pm \cdot D \cdot U_\pm \cdot D \cdot U_\pm}_{\text{ applied a certain number of times }}$ to any initial state $\ket{\phi}$


* We call the equal superposition of basis vectors in $\mathscr{B}'$ as the good state $\ket{G}$ and the superposition of vectors in $\mathscr{B} - \mathscr{B}'$ as the bad state $\ket{B}$.
* Clearly, $\ket{G}$ and $\ket{B}$ are orthonormal
* The analysis of the amplitude amplification algorithm can be done purely in a 2-d vector space, i.e. the vector space spanned by the basis $\\{ \ket{G}, \ket{B} \\}$.

---
### Amplitude Amplification Algorithm
> Given a quantum state space of an $n$-qubit register with basis $\mathscr{B} = \\{\ket{0}, \ket{1}, ..., \ket{2^n-1} \\}$, and a subbasis $\mathscr{B}'$. 
> To bring the state of the register close to a superposition of basis vectors in $\mathscr{B}'$,
> we apply the algorithm $G = \underbrace{D \cdot U_\pm \cdot....U_\pm \cdot D \cdot U_\pm \cdot D \cdot U_\pm}_{\text{ applied a certain number of times }}$ to any initial state $\ket{\phi}$

Let there be $M$ solutions out out $N = 2^n$ possibilities. Let those $M$ solutions be known as *marked states*.

Then $\ket{G} = \displaystyle \frac{1}{\sqrt{M}} \sum_{i \text{ is marked }} \ket{i}$ and $\ket{B} = \displaystyle \frac{1}{\sqrt{N-M}} \sum_{i \text{ is unmarked }} \ket{i}$

Then a state $\ket\phi$ can be uniquely decomposed as $\ket\phi = \sin\theta \ket{G} + \cos\theta \ket{B}$

Assume for simplicity that $\ket{\phi} = \ket{\psi}$ is the uniform superposition state. For analysis on a general state $\ket{\phi}$ check the [Wikipedia article, Algorithm section](https://en.wikipedia.org/wiki/Amplitude_amplification).

---
### Amplitude Amplification Algorithm
> Given a quantum state space of an $n$-qubit register with basis $\mathscr{B} = \\{\ket{0}, \ket{1}, ..., \ket{2^n-1} \\}$, and a subbasis $\mathscr{B}'$. 
> To bring the state of the register close to a superposition of basis vectors in $\mathscr{B}'$,
> we apply the algorithm $G = \underbrace{D \cdot U_\pm \cdot....U_\pm \cdot D \cdot U_\pm \cdot D \cdot U_\pm}_{\text{ applied a certain number of times }}$ to any initial state $\ket{\phi}$

$\ket\psi = \sin\theta \ket{G} + \cos\theta \ket{B}$ and  
$\ket\psi = \displaystyle \frac{\sqrt{M}}{\sqrt{N}} \ket{G} + \frac{\sqrt{N - M}}{\sqrt{N}} \ket{B}$
$\implies \theta = \arcsin(\frac{\sqrt{M}}{\sqrt{N}})$

For $M \ll N$, $\theta \approx \frac{\sqrt{M}}{\sqrt{N}}$

The phase oracle $U_\pm$ can be thought of as a reflection of the state of the register about $\ket{B}$.
$D$ is a reflection about the uniformly distributed state.

</section>

<section data-markdown>
### References
* Shor's Lecture Notes on [Grover's Algorithm](https://math.mit.edu/~shor/435-LN/Lecture_24.pdf) and [Proof of Optimality](https://math.mit.edu/~shor/435-LN/Lecture_25.pdf)
* Ryan Oâ€™Donnell Lecture Notes on [Grover's Algorithm](https://www.cs.cmu.edu/~odonnell/quantum15/lecture04.pdf)
* John Watrous Lecture Notes on [Grover's Algorithm](https://cs.uwaterloo.ca/~watrous/QC-notes/QC-notes.12.pdf) and [Analysis](https://cs.uwaterloo.ca/~watrous/QC-notes/QC-notes.13.pdf)
* Bacon's Lecture Notes on [Grover's Algorithm](https://courses.cs.washington.edu/courses/cse599d/06wi/lecturenotes12.pdf)
* Dieter van Melkebeek Lecture Notes on [Grover's Algorithm](https://pages.cs.wisc.edu/~dieter/Courses/2010f-CS880/Scribes/06/lecture06.pdf) and [Amplitude Amplification](https://pages.cs.wisc.edu/~dieter/Courses/2022s-CS710/Scribes/scribe10.pdf)
</section>

			</div>
		</div>

		<script src="dist/reveal.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
        <script src="plugin/math/math.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
                width: 1110,
                height: 700,
				hash: true,
                slideNumber: true,
				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMarkdown, RevealHighlight, RevealNotes, RevealMath.KaTeX ]
			});
		</script>
	</body>
</html>

