<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Grover's Algorithm</title>

		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/black.css">

        <link rel="stylesheet" href="css/extra/reveal_extra.css">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="plugin/highlight/monokai.css">
	</head>
	<body>
		<div class="reveal">
			<div class="slides">

<section data-markdown>
## Grover's Algorithm

Pranay Raja Krishnan

22MMT002

The LNM Institute of Information & Technology

Jaipur

</section>

<section data-markdown>
### Key Points
* Devised by Lov Kumar Grover in 1996
* One of the most famous quantum algorithm second to only Shor's algorithm
* Does not have as impressive of a speedup as Shor's but is applicable to a broader range of problems

Note:
Shor's has an exponential speedup while Grover's has only quadratic speedup
</section>

<section data-markdown>
### Computational Basis of Multiple Qubits
* For $1$ qubit, the computational basis is $\\{ \ket{0}, \ket{1} \\}$
* For $2$ qubits, the computational basis is $\\{ \ket{0}, \ket{1}, \ket{2}, \ket{3} \\}$ where 
   * $\ket{0} = \ket{00} = \ket{0} \otimes \ket{0}$
   * $\ket{1} = \ket{01} = \ket{0} \otimes \ket{1}$
   * $\ket{2} = \ket{10} = \ket{1} \otimes \ket{0}$
   * $\ket{3} = \ket{11} = \ket{1} \otimes \ket{1}$
* For $n$ qubits, the computational basis is $\\{ \ket{0}, \ket{1}, ..., \ket{2^n - 1} \\}$ where
    * $\ket{0} = \ket{00...00} = \underbrace{\ket{0} \otimes \ket{0} \otimes ... \otimes \ket{0}}_{n\text{ times }}$
    * $\ket{1} = \ket{00...01} = \underbrace{\ket{0} \otimes \ket{0} \otimes ... \otimes \ket{0}}_{n-1\text{ times }} \otimes \ket{1}$
    * $\ket{2^n - 1} = \ket{11...11} = \underbrace{\ket{1} \otimes \ket{1} \otimes ... \otimes \ket{1}}_{n\text{ times }}$
</section>


<section data-markdown>
### Hadamard Gate
> The **Hadamard gate** $H$ acts on a single qubit and is represented by the Hadamard matrix 
$H = \displaystyle\frac{1}{\sqrt{2}} \begin{bmatrix} 1 & 1 \\\\ 1 & -1 \end{bmatrix}$

* The Hadamard gate acts on $\ket{0}, \ket{1}$ as:
    * $H\ket{0} = \frac{1}{\sqrt{2}} (\ket{0} + \ket{1}) = \ket{+}$ 
    * $H\ket{1} = \frac{1}{\sqrt{2}} (\ket{0} - \ket{1}) = \ket{-}$
* The Hadamard gate is self inverse, $H H = I$

Note:
* Creates an equal superposition of the basis states
* The conjugate transponse of $H$ is $H$ itself, so to check it is unitary, we only need to check $HH = I$
* $H\ket{+} = \ket{0}$ and $H\ket{-} = \ket{1}$
</section>
<section data-markdown>
### Hadamard Transform
> The **Hadamard transform** denoted $H^{\otimes n}$ represents the application of the Hadamard gate to each qubit of an $n$-qubit register in parallel.

Consider the Hadamard tranform applied to an $n$-qubit register, each qubit set to $\ket{0}$,

$H^{\otimes n} \ket{0}^n  = \underbrace{(H \ket{0}) \otimes (H \ket{0}) \otimes (H \ket{0}) \otimes ... \otimes (H \ket{0})}_{n\text{ times }}$

$= \underbrace{\frac{1}{2^{n/2}} (\ket{0} + \ket{1}) \otimes (\ket{0} + \ket{1}) \otimes (\ket{0} + \ket{1}) ... \otimes (\ket{0} + \ket{1})}_{n \text{ times }}$ 

$= \displaystyle\frac{1}{2^{n/2}} \sum_{j=0}^{2^n -1} \ket{j} \text{ where $\ket{j}$ is the bitstring that represents $j$ in binary}$
</section>

<section data-markdown>
### Reflection about a Vector
> Given vectors $\ket\psi, \ket\phi \in \mathcal{H}$, the operator $R_\psi = 2 \ket\psi \bra\psi - I$ applied to $\ket\phi$ represents the reflection of $\ket\phi$ about the direction of $\ket\psi$

Let $\mathcal{H}_\psi^\perp \subset \mathcal{H}$ represent the subspace of $\mathcal{H}$ orthogonal to $\ket\psi$.

Let $\ket{\psi^\perp} \in \mathcal{H}_\psi^\perp$ such that $\ket{\psi^\perp} = \ket\phi - \ket\psi$ $\implies \ket\phi = \ket\psi + \ket{\psi^\perp}$

*Note:* $\ket{\psi^\perp}$ is orthogonal to $\ket\psi$

$R_\psi \ket\phi = (2 \ket\psi \bra\psi - I) \ket\phi$

$ = 2 \ket\psi \bra\psi \ket\phi - \ket\phi = 2 \ket\psi \bra\psi (\ket\psi + \ket{\psi^\perp}) - \ket\phi$

$ = 2 \ket\psi \braket{\psi|\psi} + 2 \ket\psi \braket{\psi|\psi^\perp} - \ket\phi = 2 \ket\psi - \ket\phi$

$ = 2 \ket\psi - (\ket\psi + \ket{\psi^\perp}) = \ket\psi - \ket{\psi^\perp}$

</section>
<section>
<h3>Reflection about a Vector</h3>
<blockquote><p>Given vectors $\ket\psi, \ket\phi \in \mathcal{H}$, the operator $R_\psi = 2 \ket\psi \bra\psi - I$ applied to $\ket\phi$ represents the reflection of $\ket\phi$ about the direction of $\ket\psi$</p></blockquote>

<img src="media/reflection.png" height="500"></img>
</section>

<section data-markdown>
### Problem Setup

> Given a set of $N$ elements forming a set $X = \\{ x_1, x_2, ..., x_N \\}$ and a boolean function  
> $f: X \to \\{ 0,1 \\}$, find elements $x_i \in X$ such that $f(x_i) = 1$

* We are given an unstructured search problem
* We need to search for solutions from a finite set of possible solutions
* Consider an example for such a problem:
    * A set of $N$ coins is laid out on a table heads up
    * A few of those coins are flipped so that they are tails up
    * We need to find which coins have been flipped by only looking at one coin at a time

Note:
* Unstructured means we cannot use any clever tricks like binary search
* Lov Grover designed this algorithm to be used for searching databases, where we need to match a certain query
</section>

<section data-markdown>
### Classical Approach
> Given a set of $N$ elements forming a set $X = \\{ x_1, x_2, ..., x_N \\}$ and a boolean function  
> $f: X \to \\{ 0,1 \\}$, find elements $x_i \in X$ such that $f(x_i) = 1$

* Consider the case where there is only $1$ possible solution
* The only classical deterministic algorithm is to query the function $f$ with each value of $x_i \in X$ until we find a solution
* On average we will require $\frac{N}{2}$ queries to $f$ to determine the solution, and in the worst case we will need $N$ queries to $f$
* This means that the algorithm will have a time complexity of $O(N)$
---
### Classical Approach
> Given a set of $N$ elements forming a set $X = \\{ x_1, x_2, ..., x_N \\}$ and a boolean function  
> $f: X \to \\{ 0,1 \\}$, find elements $x_i \in X$ such that $f(x_i) = 1$

* When the number of solutions is not known, any deterministic algorithm will need to query all $N$ possibilities to check if each one is a solution
* We will need $N$ queries to $f$ in the average and worst case 
* This means that the time complexity for any classical deterministic algorithm is $O(N)$

Note: 
* When we know the number of solutions, say $t$ solutions among $N$ possibilities, a randomized algorithm will give a time complexity of $O(\frac{N}{t})$
</section>

<section data-markdown>
### Grover's Algorithm
> Given a set of $N$ elements forming a set $X = \\{ x_1, x_2, ..., x_N \\}$ and a boolean function  
> $f: X \to \\{ 0,1 \\}$, find elements $x_i \in X$ such that $f(x_i) = 1$

* To make the solution space easier to work with, first label the values $x_i \in X$ directly as $i - 1$, so
$X = \\{0, 1, 2, ..., N - 1\\}$ and redefine $f$ so that $f(i - 1) = f(x_i)$ 
* Also consider (WLOG) that $N = 2^n$

</section>

<section data-markdown>
### Oracle
* Equivalence of flip and sign oracles
</section>

<section data-markdown>
### Analysis
* Time Complexity Analysis
* Gate Complexity Analysis
</section>

<section data-markdown>
### References
* Ronald de Wolf [Video Lecture on Grover's Algorithm](https://www.youtube.com/watch?v=tCAKqpXW2CY)
* Shor's Lecture Notes on Grover's Algorithm [Introduction](https://math.mit.edu/~shor/435-LN/Lecture_24.pdf) and [Proof of Optimality](https://math.mit.edu/~shor/435-LN/Lecture_25.pdf)
* Ryan Oâ€™Donnell [Lecture Notes on Grover's Algorithm](https://www.cs.cmu.edu/~odonnell/quantum15/lecture04.pdf)
* John Watrous [Lecture Notes on Grover's Algorithm 01](https://cs.uwaterloo.ca/~watrous/QC-notes/QC-notes.12.pdf) and [Grover's Algorithm 02](https://cs.uwaterloo.ca/~watrous/QC-notes/QC-notes.13.pdf)
* Bacon's [Lecture Notes on Grover's Algorithm](https://courses.cs.washington.edu/courses/cse599d/06wi/lecturenotes12.pdf)
* Dieter van Melkebeek [Lecture Notes on Grover's Algorithm](https://pages.cs.wisc.edu/~dieter/Courses/2010f-CS880/Scribes/06/lecture06.pdf)
</section>

			</div>
		</div>

		<script src="dist/reveal.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
        <script src="plugin/math/math.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
                width: 1110,
                height: 700,
				hash: true,
                slideNumber: true,
				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMarkdown, RevealHighlight, RevealNotes, RevealMath.KaTeX ]
			});
		</script>
	</body>
</html>

