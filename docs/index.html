<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Grover's Algorithm</title>

		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/black.css">

        <link rel="stylesheet" href="css/extra/reveal_extra.css">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="plugin/highlight/monokai.css">
	</head>
	<body>
		<div class="reveal">
			<div class="slides">

<section data-markdown>
## Grover's Algorithm

Pranay Raja Krishnan

22MMT002

The LNM Institute of Information & Technology

Jaipur

</section>

<section data-markdown>
### Key Points
* Devised by Lov Kumar Grover in 1996
* One of the most famous quantum algorithm second to only Shor's algorithm
* Does not have as impressive of a speedup as Shor's but is applicable to a broader range of problems

Note:
Shor's has an exponential speedup while Grover's has only quadratic speedup
</section>

<section data-markdown>
### Hadamard Gate
> The **Hadamard gate** $H$ acts on a single qubit and is represented by the Hadamard matrix 
$H = \displaystyle\frac{1}{\sqrt{2}} \begin{bmatrix} 1 & 1 \\\\ 1 & -1 \end{bmatrix}$

* The Hadamard gate acts on $\ket{0}, \ket{1}$ as:
    * $H\ket{0} = \frac{1}{\sqrt{2}} (\ket{0} + \ket{1}) = \ket{+}$ 
    * $H\ket{1} = \frac{1}{\sqrt{2}} (\ket{0} - \ket{1}) = \ket{-}$
* The Hadamard gate is self inverse, $H H = I$

Note:
* Creates an equal superposition of the basis states
* The conjugate transponse of $H$ is $H$ itself, so to check it is unitary, we only need to check $HH = I$
* $H\ket{+} = \ket{0}$ and $H\ket{-} = \ket{1}$
</section>
<section data-markdown>
### Hadamard Transform
> The **Hadamard transform** denoted $H^{\otimes n}$ represents the application of the Hadamard gate to each qubit of an $n$-qubit register in parallel.

Consider the Hadamard tranform applied to an $n$-qubit register, each qubit set to $\ket{0}$,

$H^{\otimes n} \ket{0}^n  = \underbrace{(H \ket{0}) \otimes (H \ket{0}) \otimes (H \ket{0}) \otimes ... \otimes (H \ket{0})}_{n\text{ times }}$

$= \underbrace{\frac{1}{2^{n/2}} (\ket{0} + \ket{1}) \otimes (\ket{0} + \ket{1}) \otimes (\ket{0} + \ket{1}) ... \otimes (\ket{0} + \ket{1})}_{n \text{ times }}$ 

$= \displaystyle\frac{1}{2^{n/2}} \sum_{j=0}^{2^n -1} \ket{j} \text{ where $\ket{j}$ is the bitstring that represents $j$ in binary}$
</section>

<section data-markdown>
### Reflection about a Vector
> Given vectors $\ket\psi, \ket\phi \in \mathcal{H}$, the operator $R_\psi = 2 \ket\psi \bra\psi - I$ applied to $\ket\phi$ represents the reflection of $\ket\phi$ about the direction of $\ket\psi$

Let $\mathcal{H}_\psi^\perp \subset \mathcal{H}$ represent the subspace of $\mathcal{H}$ orthogonal to $\ket\psi$.

Let $\ket{\psi^\perp} \in \mathcal{H}_\psi^\perp$ such that $\ket{\psi^\perp} = \ket\phi - \ket\psi$ $\implies \ket\phi = \ket\psi + \ket{\psi^\perp}$

*Note:* $\ket{\psi^\perp}$ is orthogonal to $\ket\psi$

$R_\psi \ket\phi = (2 \ket\psi \bra\psi - I) \ket\phi$

$ = 2 \ket\psi \bra\psi \ket\phi - \ket\phi = 2 \ket\psi \bra\psi (\ket\psi + \ket{\psi^\perp}) - \ket\phi$

$ = 2 \ket\psi \braket{\psi|\psi} + 2 \ket\psi \braket{\psi|\psi^\perp} - \ket\phi = 2 \ket\psi - \ket\phi$

$ = 2 \ket\psi - (\ket\psi + \ket{\psi^\perp}) = \ket\psi - \ket{\psi^\perp}$

</section>
<section>
<h3>Reflection about a Vector</h3>
<blockquote><p>Given vectors $\ket\psi, \ket\phi \in \mathcal{H}$, the operator $R_\psi = 2 \ket\psi \bra\psi - I$ applied to $\ket\phi$ represents the reflection of $\ket\phi$ about the direction of $\ket\psi$</p></blockquote>

<img src="media/reflection.png" height="500"></img>
</section>

<section data-markdown>
### Problem Setup
> Grover's Search Algorithm targets an unstructured search problem.
>
>
</section>

<section data-markdown>
### Algorithm Summary
</section>

<section data-markdown>
### Oracle
* Equivalence of flip and sign oracles
</section>

<section data-markdown>
### Analysis
* Time Complexity Analysis
* Gate Complexity Analysis
</section>

<section data-markdown>
### References
* Ronald de Wolf [Video Lecture on Grover's Algorithm](https://www.youtube.com/watch?v=tCAKqpXW2CY)
* Shor's Lecture Notes on Grover's Algorithm [Introduction](https://math.mit.edu/~shor/435-LN/Lecture_24.pdf) and [Proof of Optimality](https://math.mit.edu/~shor/435-LN/Lecture_25.pdf)
* Ryan Oâ€™Donnell [Lecture Notes on Grover's Algorithm](https://www.cs.cmu.edu/~odonnell/quantum15/lecture04.pdf)
* John Watrous [Lecture Notes on Grover's Algorithm 01](https://cs.uwaterloo.ca/~watrous/QC-notes/QC-notes.12.pdf) and [Grover's Algorithm 02](https://cs.uwaterloo.ca/~watrous/QC-notes/QC-notes.13.pdf)
* Bacon's [Lecture Notes on Grover's Algorithm](https://courses.cs.washington.edu/courses/cse599d/06wi/lecturenotes12.pdf)
* Dieter van Melkebeek [Lecture Notes on Grover's Algorithm](https://pages.cs.wisc.edu/~dieter/Courses/2010f-CS880/Scribes/06/lecture06.pdf)
</section>

			</div>
		</div>

		<script src="dist/reveal.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
        <script src="plugin/math/math.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
                width: 1110,
                height: 700,
				hash: true,
                slideNumber: true,
				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMarkdown, RevealHighlight, RevealNotes, RevealMath.KaTeX ]
			});
		</script>
	</body>
</html>

